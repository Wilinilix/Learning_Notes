:stem: latexmath
:icons: font
:source-highlighter: coderay
:sectnums:
:sectlinks:
:sectnumlevels: 4
:toc: left
:toc-title: Table of contents
:toclevels: 4 

= Taichi


== Taichi Basics
The gene of Taichi is parallel computing.

=== Data format

Tensor is a multidim array whose elements can be everything even matrices.

```py
import taichi as ti
ti.init()

a = ti.var(dt=ti.f32, shape=(42,63)) # a tensor of 42X63 scalars
b = ti.Vector(3, dt=ti.f32, shape=4) # a tensor of 4X3D vectors
c = ti.Matrix(2,2,dt=ti.f32,shape=(3,5)) # a tensor of 3X5 2X2 matrices
# ti.* defines the type of each element and the first part defines the size of each element
loss = ti.var(dt=ti.f32, shape=()) # this is a scalar defined in tensor form
loss[None]=3 # use this to assign value to a scalar in a tensor form
```

=== Kernel and function

In Taichi, kernel is the computation function.
Kernels must be decorated with @ti.kernel. They can call functions but cannot be call other kernels.
Taichi functions can be called directly by Taichi kernels and other Taichi functions but not python. Only **one return** is supported up to now. They must be decorated with @ti.func.

Element-wise product *; marix product @.

=== For loops

For loops in Taichi have 2 forms.
+ Range-for loops: Similar to Python. Will be parallelized when used at the outermost scope.
+ Struct-for loops: Iterates over (sparse) tensor elements.
For loops at the outermost scope in Taichi is *automatically parallelized*.

```py
ti.init(arch=ti.gpu)
n = 320
pixels = ti.var(dt=ti.f32, shape=(2*n, n))
@ti.kernel
def paint(t:ti.f32):
    for i,j in pixels:
        pixels[i,j] = i*3+j*4+t
```

=== Atomic operations

Atomic operation is designed to deal with parallel computing. An atomic operation will go from start to finish without interruption of other threads.
In Taichi, augmented assignments (x[i]+=1)
```py
a[None] += 1 [right]
ti.atomic_add(a[None], 1) [right]
a[None] = a[None] + 1 [wrong]
```

=== Scope

Taichi-scope: in @ti.kernel or @ti.func. Compiled in Taichi and run in parallel.

Python-scope: Compiled in Python.

=== Phases of a Taichi program

* Initialization: ti.init(...)
* Tensor allocation: ti.var, ti.Vector, ti.Matrix
* Computation (lauch kernels...)
* Optional: restart the Taichi system (clear memory, destroy variables and kernels...) ti.reset()

[NOTE]
====
After the first ti.kernel, no more tensor allocation is allowed.
====

[source,python]
----
# fractal.py
import taichi as ti
ti.init(arch=ti.cpu)

n=320
pixels = ti.var(dt=ti.f32, shape=(2*n, n))

@ti.func
def complex_sqr(z):
    return ti.Vector([z[0]**2 - z[1]**2, z[1] * z[0] *2])

@ti.kernel
def paint(t: ti.f32):
    for i,j in pixels:
        c = ti.Vector([-0.8, ti.cos(t) * 0.2])
        z = ti.Vector([i/n - 1, j/n - 0.5]) * 2
        iterations = 0
        while z.norm() < 20 and iterations < 50:
            z = complex_sqr(z) + c
            iterations += 1
        pixels[i, j] = 1 - iterations * 0.02

gui = ti.GUI("Julia Set", res=(n * 2, n))
for i in range(1000000):
    paint(i * 0.03)
    gui.set_image(pixels)
    gui.show()
----

=== Debug mode

debug = True (cpu only)
```py
ti.init(debug=True, arch=ti.cpu)
a = ti.var(dt=ti.f32, shape=(10))
b = ti.var(dt=ti.f32, shape=(10))
@ti.kernel
def shift():
    for i in range(10):
        a[i] = b[i+1]
# bound checker is only activated in debug mode to save time in normal mode.
shift()
```

== Lagrangian and Eulerian View

Lagrangian view: move with object.

Eulerian view: static.

=== Lagrangian simulation approaches

==== Mass-spring system

Hook's law
[math,file="Taichi_images/Hooke's law.png"]
--
f_{ij}=-k()
--



=== Eulerian view

.标题
****
高科技
****

[quote, yzj]
jdkjgdjkg

djjgkj

.表格1
[options="header,footer"]
|====
|列 1 |列 2       |列 3
|1    |Item 1     |a
|2    |Item 2     |b
|3    |Item 3     |c
|6    |Three items|d
|====

.表格2
|====
|日期 |持续时间 |平均时间 |备注
|22-Aug-08 .2+^.^|10:24 | 157 |备注
|22-Aug-08 | 152 |备注
|24-Aug-08 3+^|none
|====

[math,file="Taichi_images/tex-formula.png"]
--
\begin{align}
\dot{x} & = \sigma(y-x) \\
\dot{y} & = \rho x - y - xz \\
\dot{z} & = -\beta z + xyp
\end{align}
--


